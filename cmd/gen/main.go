package main

import (
	"fmt"
	"log"
	"os"
	"path/filepath"
	"sort"
	"strings"

	"github.com/bwmarrin/discordgo"
	bot "github.com/ritehand/asagumo"
)

func main() {
	if bot.Token == "" {
		log.Fatal("BOT_TOKEN is not set in github.com/ritehand/asagumo")
	}
	if bot.GuildID == "" {
		log.Fatal("GUILD_ID is not set in github.com/ritehand/asagumo")
	}

	s, err := discordgo.New("Bot " + bot.Token)
	if err != nil {
		log.Fatalf("Invalid bot token: %v", err)
	}

	// Fetch roles
	roles, err := s.GuildRoles(bot.GuildID)
	if err != nil {
		log.Fatalf("Failed to fetch roles: %v", err)
	}

	roleMap := make(map[string]string)
	for _, r := range roles {
		roleMap[r.ID] = r.Name
	}

	// Fetch channels
	channels, err := s.GuildChannels(bot.GuildID)
	if err != nil {
		log.Fatalf("Failed to fetch channels: %v", err)
	}

	const PermissionViewChannel = 1 << 10

	// Process channels
	type channelData struct {
		ID           string
		Name         string
		IsPrivate    bool
		AllowedRoles []string
	}
	channelMap := make(map[string]channelData)
	for _, c := range channels {
		isPrivate := false
		var allowedRoles []string

		// Determine privacy and allowed roles
		for _, overwrite := range c.PermissionOverwrites {
			if overwrite.Type == discordgo.PermissionOverwriteTypeRole {
				// Access ViewChannel permission
				allow := (overwrite.Allow & PermissionViewChannel) != 0
				deny := (overwrite.Deny & PermissionViewChannel) != 0

				if overwrite.ID == bot.GuildID { // @everyone role
					if deny {
						isPrivate = true
					}
				} else {
					if allow {
						allowedRoles = append(allowedRoles, overwrite.ID)
					}
				}
			}
		}
		sort.Strings(allowedRoles)

		channelMap[c.Name] = channelData{
			ID:           c.ID,
			Name:         c.Name,
			IsPrivate:    isPrivate,
			AllowedRoles: allowedRoles,
		}
	}

	// Generate Go code
	var sb strings.Builder
	sb.WriteString("// Code generated by cmd/gen/main.go. DO NOT EDIT.\n\n")
	sb.WriteString("package gen\n\n")
	sb.WriteString("func init() {\n")

	// Roles
	sb.WriteString("\troles = map[string]RoleInfo{\n")
	roleIDs := make([]string, 0, len(roleMap))
	for id := range roleMap {
		roleIDs = append(roleIDs, id)
	}
	sort.Strings(roleIDs)
	for _, id := range roleIDs {
		sb.WriteString(fmt.Sprintf("\t\t%q: {ID: %q, Name: %q},\n", id, id, roleMap[id]))
	}
	sb.WriteString("\t}\n\n")

	// Channels
	sb.WriteString("\tchannels = map[string]ChannelInfo{\n")
	channelNames := make([]string, 0, len(channelMap))
	for name := range channelMap {
		channelNames = append(channelNames, name)
	}
	sort.Strings(channelNames)

	for _, name := range channelNames {
		info := channelMap[name]
		allowedStr := "nil"
		if len(info.AllowedRoles) > 0 {
			allowedStr = fmt.Sprintf("[]string{%s}", strings.Join(quoteList(info.AllowedRoles), ", "))
		}
		sb.WriteString(fmt.Sprintf("\t\t%q: {ID: %q, Name: %q, IsPrivate: %v, AllowedRoles: %s},\n",
			name, info.ID, info.Name, info.IsPrivate, allowedStr))
	}

	sb.WriteString("\t}\n")
	sb.WriteString("\tchannelsErr = nil\n")
	sb.WriteString("}\n")

	// Helper for quoting strings in slice
	_ = quoteList // silence lint if needed

	outDir := "gen"
	outFile := filepath.Join(outDir, "generated.go")

	if err := os.MkdirAll(outDir, 0755); err != nil {
		log.Fatalf("Failed to create directory: %v", err)
	}

	if err := os.WriteFile(outFile, []byte(sb.String()), 0644); err != nil {
		log.Fatalf("Failed to write file: %v", err)
	}

	fmt.Printf("Successfully generated %s with %d channels and %d roles\n", outFile, len(channelMap), len(roleMap))
}

func quoteList(list []string) []string {
	res := make([]string, len(list))
	for i, s := range list {
		res[i] = fmt.Sprintf("%q", s)
	}
	return res
}
